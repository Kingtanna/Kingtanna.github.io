<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kingtanna的秘密花园</title>
  
  <subtitle>欢迎来到我的世界</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-09T06:31:07.886Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Kingtanna</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Webdriver工作原理</title>
    <link href="http://yoursite.com/2020/06/09/Webdriver%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/06/09/Webdriver%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</id>
    <published>2020-06-09T02:43:29.000Z</published>
    <updated>2020-06-09T06:31:07.886Z</updated>
    
    <content type="html"><![CDATA[<p>工作以来一直在使用selenium或者说是webdriver进行web UI的测试，基本流程为首先了解需求从而构建测试用例，然后就开始写测试代码，例如给元素定位，写调用函数等。直到昨天，我问自己webdriver究竟是如何来做测试的，或者说它的运行原理是什么。我这才意识到，我每日都在使用的工具，但实际上我并没有真正懂得它的工作原理。所谓知其然但不知其所以然大概就是这种现象吧。心中顿感羞愧，于是赶紧恶补了webdriver的相关底层知识。</p><a id="more"></a><p>在网上看了十几篇相关的介绍后，有一个例子给我留下了深刻的印象，这里我依然想引用这个例子来加强印象和理解。大家都有坐出租车的经验，这个过程一般为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">乘客告诉司机目的地地址</span><br><span class="line">司机操作出租车，例如直行1.3公里，先右拐，再左拐等等</span><br><span class="line">出租车按照指令行驶，最终到达目的地</span><br></pre></td></tr></table></figure><p>在上述这个例子中，乘客为请求发出者，司机为请求解析者，出租车为最终请求执行者。类比到使用webdriver做测试的过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">乘客告诉司机目的地地址  --&gt; 测试代码发出测试请求，其中包括对浏览器的各项操作</span><br><span class="line">司机操作出租车，例如直行1.3公里，先右拐，再左拐等等  --&gt; 浏览器驱动接受并解析请求，将解析的结果发给浏览器</span><br><span class="line">出租车按照指令行驶，最终到达目的地  --&gt;  浏览器执行请求中的各项操作</span><br></pre></td></tr></table></figure><p>对应成图来理解就是：<br><img src="/2020/06/09/Webdriver%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/工作原理1.png">  </p><p>问题来了，假如出租车司机遇到了外国乘客，他很有可能听不懂外国乘客的语言，这样出租车司机就有可能无法完成这一单生意。同样的，不同的项目可能使用不同的语言，那么在写测试用例的时候，webdriver又怎么保证每个语言它都能解析呢？<br>为了回答上述问题首先来看看请求是什么？向浏览器发送请求是基于http协议，这个协议规定了每一个请求的格式，包括http请求头，请求内容，也就是说不论是什么语言，所发出的http请求的格式是一致的。而webdriver是基于JSON Wire Protocol这个协议，该协议会将所有的请求统一处理为json的格式，也就是说编写测试代码的语言也许不一致，但是当测试代码的请求到达webdriver的时候这些请求就被处理成了统一的格式。因此使用webdriver时就与语言解耦了，这个过程可以用下面的图来解释。<br><img src="/2020/06/09/Webdriver%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/工作原理2.png">  </p><p>以上就是webdriver的基本工作原理，通过这次对webdriver原理的追根溯源，我意识到学习知识一定要多问几个为什么。有时候总会以为自己懂了，但实际上根本不懂，又或者所学到的知识都是散落的点，无法从点到面，形成一个系统化的知识框架。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工作以来一直在使用selenium或者说是webdriver进行web UI的测试，基本流程为首先了解需求从而构建测试用例，然后就开始写测试代码，例如给元素定位，写调用函数等。直到昨天，我问自己webdriver究竟是如何来做测试的，或者说它的运行原理是什么。我这才意识到，我每日都在使用的工具，但实际上我并没有真正懂得它的工作原理。所谓知其然但不知其所以然大概就是这种现象吧。心中顿感羞愧，于是赶紧恶补了webdriver的相关底层知识。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TestNG+Appium+GoCD自动化测试框架搭建</title>
    <link href="http://yoursite.com/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-01T09:19:58.000Z</published>
    <updated>2020-06-08T02:57:51.928Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了TestNG和GoCD的知识，并且已经利用Appium和Java写了简单的基于page object的mobile测试用例。现在将它们联合起来，搭建一个可使用的自动化测试框架。使用到的工具或者框架如下：</p><a id="more"></a><p>1.Java - 编码语言<br>2.Appium - mobile测试工具<br>3.TestNG - 单元测试框架<br>4.Maven - 项目构建和管理工具<br>5.GoCD - 持续集成和部署工具</p><h3 id="一-使用Maven来管理项目"><a href="#一-使用Maven来管理项目" class="headerlink" title="一 使用Maven来管理项目"></a>一 使用Maven来管理项目</h3><p>之前在建立测试项目时，使用的是Gradle。由于最近新学习了Maven，所以将其改成Maven项目来巩固Maven的知识。新建一个Maven项目，将之前的代码拷贝进去。<br><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/maven管理项目.png" width="40%"></p><h3 id="二-添加相关依赖和插件"><a href="#二-添加相关依赖和插件" class="headerlink" title="二 添加相关依赖和插件"></a>二 添加相关依赖和插件</h3><p>点击pom.xml文件，然后在工具栏选择code-&gt;generate-&gt;dependencies，分别添加testng依赖、appium client依赖，还有surefire插件。之所以添加这个插件是因为maven本身不执行测试，需要这个插件来执行测试。添加以后这些依赖会自动添加到pom.xml文件中，但是需要手动点击这些依赖右上方的 <code>m</code> 来真正下载这些依赖。<br><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/添加依赖1.png" width="50%">   </p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/添加依赖2.png" width="50%"><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/dependency.png" width="50%"><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/plugin.png" width="50%"><h3 id="三-添加xml文件"><a href="#三-添加xml文件" class="headerlink" title="三 添加xml文件"></a>三 添加xml文件</h3><p>由于使用TestNG时需要使用testng.xml文件来运行测试用例，而在建立项目时该文件不会自动生成，因此需要手动去创建该文件，并且添加相应的配置代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;Default Suite&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;Demo&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.demo1&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line"></span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br></pre></td></tr></table></figure>  <h3 id="四-push测试代码到GitHub仓库"><a href="#四-push测试代码到GitHub仓库" class="headerlink" title="四 push测试代码到GitHub仓库"></a>四 push测试代码到GitHub仓库</h3><p>在上述三个步骤做完后，测试代码可以顺利运行。在此基础之上，将本地代码push到远程的GitHub仓库。具体操作步骤，这里不再赘述。</p><h3 id="五-实现持续集成和部署"><a href="#五-实现持续集成和部署" class="headerlink" title="五 实现持续集成和部署"></a>五 实现持续集成和部署</h3><p>1.打开terminal，分别进入到GoCD server和agent目录下，启动server和agent。<br>2.打开浏览器，输入<a href="http://localhost:8153/go/pipelines#!/" target="_blank" rel="noopener">http://localhost:8153/go/pipelines#!/</a> ， 进入到GoCD页面。该页面就会提醒新建一个pipeline。下面就按照提示一步步来操作。  </p><ul><li><p><strong>增加material，这里我放的是之前测试代码的仓库地址。可以点击绿色的按钮，测试连接是否成功。</strong></p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline1.png" width="100%">  <img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline2.png" width="100%"></li><li><p><strong>添加Pipeline</strong></p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline3.png" width="100%">  </li><li><p><strong>添加Stage</strong></p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline4.png" width="100%">    </li><li><p><strong>添加Job和Task</strong></p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline5.png" width="100%">  </li><li><p><strong>生成Pipeline</strong></p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/automationMobileTesting/CreatePipeline6.png" width="100%">  </li></ul><p>经过以上步骤后就生成了一个最简单的pipeline，接下来可以根据需要来设置pipeline的参数，例如运行时间，运行命令和显示测试报告等。</p><h3 id="六-设置Pipeline"><a href="#六-设置Pipeline" class="headerlink" title="六 设置Pipeline"></a>六 设置Pipeline</h3><p><strong>1.设置Pipeline的material地址。</strong>在前面我们新建Pipeline的时候添加过material，现在再次进入material设置界面确认一下是否添加正确，若没有再补上即可。其中有一项是Destination directory，它的作用是新建一个对应名字的文件夹，在pipeline运行时，将下载下来的代码存放在该文件夹下。这个路径是一个相对路径，位置为GoCD文件夹/go-agent文件夹/pipelines/Destination directory文件夹。例如我填的是AutoMobileTetsing,那么我的代码存放路径为：GOCD/go-agent-20.3.0/pipelines/AutoMobileTetsing。<br><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/material1.png"><br><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/material1.png"></p><p><strong>2.添加task。</strong>一个task通常就是一条命令，这里我们加上<code>mvn test</code>这个命令来运行测试代码。在下图<strong>1</strong>处输入mvn时即会出现相关的命令，然后选择测试命令，左边<strong>2</strong>区域里就会自动填上选择的命令。最后填上Working Directory，这个路径指的是命令生效的路径，那么这里填的就是之前代码下载下来的路径。同样的，这也是一个相对路径。<br><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/Task.png"></p><p><strong>3.添加artifacts。</strong>每个Job都可以产生artifacts，通过artifacts可以知道代码运行的情况。对于测试而言，最终是需要产生测试报告来评估测试的结果。这里通过添加artifacts来展示测试结果。</p><ul><li><p>设置artifacts，如下图所示，Source中填agent上surefire reports的地址，其路径为：GoCD文件夹/go-agent文件夹/pipelines/material地址/代码仓库/target/surefire-reports。Destination上填在server上surefire reports的存放地址，这个地址是在GoCD文件夹/go-agent文件夹/artifacts/pipelines/下。这两个地址的路径都属于相对路径。</p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/artifacts.png">  </li><li><p>添加tap。为了方便的显示测试结果，可以增加一个tap，后面只要点击tap就可以看到测试结果。下图的路径就是上一步中我们填的server上report的地址</p><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/tap.png">上述两个步骤做完后，就可以看到运行结果。<img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/results.png"><img src="/2020/06/01/TestNG-Appium-GoCD%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/results2.png"></li></ul><p>经过上述步骤后就搭建起来了一个简单的mobile自动化测试框架，后续在此基础再添加新的pipeline，新的设置，或者新的测试代码。在搭建过程中可能会遇到一些问题，可以通过console打印出的error找出问题所在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前学习了TestNG和GoCD的知识，并且已经利用Appium和Java写了简单的基于page object的mobile测试用例。现在将它们联合起来，搭建一个可使用的自动化测试框架。使用到的工具或者框架如下：&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>ZSH使用小技巧</title>
    <link href="http://yoursite.com/2020/05/28/ZSH%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://yoursite.com/2020/05/28/ZSH%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-05-28T09:26:28.000Z</published>
    <updated>2020-06-05T02:10:21.654Z</updated>
    
    <content type="html"><![CDATA[<p>什么是ZSH,待补充~ 先码上ZSH使用小技巧。  </p><a id="more"></a><p>ZSH使用小技巧为：<br><strong>1.切换路径</strong><br>改变路径时不需要使用cd，直接输入想要去的路径就可以了。  </p><p><strong>2.查看和修改主题</strong><br>打开~/.zshrc文件，修改ZSH_THEME的值可以修改ZSH的主题,查看有哪些主题的命令：ls ~/.oh-my-zsh/themes。</p><p><strong>3.查看当前使用shell类型</strong><br>查看当前使用shell类型的命令为：echo $SHELL。</p><p><strong>4.自动补全</strong><br>按下tab键自动补全。</p><p><strong>5.回退</strong><br>快速回退目录：按下..可以回到上层目录，按下…可以回到上两目录。</p><p><strong>6.快速进入历史路径</strong><br>快速回访历史访问路径记录:在当前目录下，输入d可以在下面打印出历史路径，并且输入路径前面的序列号，可以快速进入之前的路径。</p><p><strong>7.编辑快捷键</strong><br>ctrl-A - 移动到行的开头<br>ctrl-E - 移动到行尾<br>ctrl-U - 清除行（光标位置前）<br>ctrl-W - 删除光标位置前的单词 </p><p><strong>8.搜索命令历史记录</strong><br>先输入命令ctrl+r，接着输入命令的关键字就可自动出现所对应的命令。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是ZSH,待补充~ 先码上ZSH使用小技巧。  &lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GoCD基本概念</title>
    <link href="http://yoursite.com/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2020-05-27T08:25:24.000Z</published>
    <updated>2020-06-05T02:10:21.625Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始学习GoCD的知识，首先把其中的一些基础概念弄清楚。以下概念是阅读完官方文档后记录下来的，方便自己随时翻阅。</p><a id="more"></a>  <p><strong>1.Task：</strong>任务或者一个构建任务，是一个需要被执行的操作。通常task是一个命令。例如下图中的命令<code>ant -Dmodule=A compile</code>是一个task。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/task.png" width="30%"></p><p><strong>2.Job：</strong>Job通常由多个顺序执行的task组成。如果其中一个task失败了那么这个Job就被视为失败。并且这个Job中剩余的task也不会运行。Job中的每个task都作为独立程序运行，因此，task对其任何环境变量所做的更改都不会影响后续task。task在文件系统上所做的任何更改将对后续task可见。例如下图中，Job包含3个task。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/Job.png" width="30%"></p><p><strong>3.Stage：</strong>Stage由多个独立执行的Job组成，这意味着GoCD确实是并行执行Stage中的Job。 如果一个Job失败了，那么，包含这个Job的Stage也被认为是失败的。但是因为Job之间是独立运行的，所以其他的Job仍然会继续执行直到结束。例如下图中，Stage包含两个Job且这两个Job是并行的。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/Stage.png" width="30%"></p><p><strong>4.Pipeline：</strong>Pipeline是由多个顺序执行的Stages组成。如果其中一个Stage失败，那么就认为这个Pipeline是失败的。接下来的Stage不会被执行。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pipeline.png"></p><p><strong>5.Materials和triggers：</strong>material会触发Pipeline开始执行。通常它是指源代码仓库。GoCD Server持续轮询配置material当发现新的更改或提交时，相应的Pipeline将运行或“触发”。时间触发器是一种特殊的material，它会在特定的时间里面触发Pipeline。Pipeline甚至可以配置多种material，当任一存储库有新的提交时，都会触发Pipeline开始执行。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/material.png" width="50%"></p><p><strong>6.Pipeline dependency material：</strong>当有多个Pipeline时，且后执行的Pipeline依赖于先执行Pipeline的执行结果，那么先执行的Pipeline称为上游Pipeline，后执行的Pipeline称为下游Pipeline。例如下图中，Pipeline1是上游Pipeline，Pipeline2是下游Pipeline。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/pipleine dependency.png"></p><p><strong>7.Fan-out和fan-in：</strong>如果一个material的执行结束会触发多个下游Pipeline运行，那么这个material会被视为fan-out.相反如果一个下游Pipeline的触发需要多个上游material，那么这个就被视作fan-in。对于fan-in的Pipeline，GOCD会在上游所有所需material执行完毕后才触发。例如下图中的第一个图，Pipeline3需要Pipeline1和Pipeline2完成后才能被触发，那么这种情况是fan in，且假如Pipeline1和Pipeline2的stage不是同时完成，那么Pipeline3要等到最后一个stage成功完成后才会被触发。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/fan in.png" width="70%"><br>下图中，Pipeline1的完成会触发多个下游的Pipeline运行，所以这种情况会被视为fan-out。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/fan out.png" width="70%"></p><p><strong>8.Artifacts：</strong>Artifacts是指文件或者文件夹。Go中的每个Job可以选择是否发布Artifacts，并且GOCD会让发布的Artifacts对用户和其他下游Stages或者Pipeline可见。<br><img src="/2020/05/27/GoCD%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/artifacts.png" width="50%"></p><p><strong>9.Agent：</strong>Agent就像是GOCD系统的工人，所有的任务将会在agent上执行。</p><p><strong>10.Resource：</strong>标记agent的标签，标识agent上有哪些资源，用来判断再该agent上是不是可以执行某种任务。</p><p><strong>11.Environments：</strong>GoCD中的Environments是对Pipeline和agent进行分组和隔离的一种方式。</p><ul><li>一个Pipeline最多与一个Environment相关联</li><li>一个agent可以与多个Environment相关联，也可不与Environment相关联</li><li>一个agent只能在与其关联的Environment中拾取属于Pipeline的task。</li><li>与某个Environment关联的agent不能在与任何环境无关联的Pipeline中执行task。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近开始学习GoCD的知识，首先把其中的一些基础概念弄清楚。以下概念是阅读完官方文档后记录下来的，方便自己随时翻阅。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TestNG的XML文件小结</title>
    <link href="http://yoursite.com/2020/05/25/TestNG%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/25/TestNG%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/</id>
    <published>2020-05-25T05:46:14.000Z</published>
    <updated>2020-06-05T02:10:21.651Z</updated>
    
    <content type="html"><![CDATA[<p>当使用TestNG来运行测试用例时，一个典型的步骤为： </p><ul><li>编写测试业务逻辑代码并添加TestNG的注解</li><li>在testng.xml配置测试信息</li><li>运行TestNG  </li></ul><p>这个xml文件在这里就起到了关键作用。举个例子来说：在做菜的时候我们可能会去看菜谱，菜谱会告诉我们要放哪些调料，以及放的顺序。但是我们也可以按照我们自己的需求来修改菜谱，也就是说最后的菜是按照自定义的配置做出来的。如果将自动化测试类比为做菜的过程，那么xml文件在这里的作用就是按照需求去自定义配置菜谱的过程。最后测试用例就是按照我们的配置来运行。</p><a id="more"></a><p>xml文件的内容如下：<br><img src="/2020/05/25/TestNG%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/xml文件目录.png"><br>从图中可以看到，xml文件主要包含三大部分:&lt;suite&gt;，&lt;test&gt;，&lt;parameter&gt;。一个典型的xml文件的格式如下图所示。<br><img src="/2020/05/25/TestNG%E7%9A%84XML%E6%96%87%E4%BB%B6%E5%B0%8F%E7%BB%93/xml文件格式.png" width="100%" height="80%"> </p><p><strong>1.&lt;suite&gt;</strong>  </p><p>&lt;suite&gt;是testng.xml文档中最上层的元素，一个xml文件只能有一个<suite>，它是一个xml文件的根级。&lt;suite&gt;下可包含&lt;parameter&gt;元素<br>以及多个&lt;test&gt;标签。&lt;suite&gt;标签下有很多参数，每个参数的作用如下表所示:  </suite></p><table><thead><tr><th>参数</th><th>说明</th><th>使用方法</th><th>参数值</th></tr></thead><tbody><tr><td>name</td><td>必选项，&lt;suite&gt;的名字，将出现在reports里</td><td>name=”XXX”</td><td>suite名字</td></tr><tr><td>junit</td><td>是否执行Junit模式(识别setup()等)</td><td>junit=”true”</td><td>true和false，默认false</td></tr><tr><td>verbose</td><td>控制台输出的详细内容等级,0-10级（0无，10最详细）</td><td>verbose=”5”</td><td>0到10</td></tr><tr><td>parallel</td><td>是否在不同的线程并行进行测试，要与thread-count配套使用</td><td>parallel=”mehods”</td><td>详见表格下内容，默认false</td></tr><tr><td>parent-module</td><td>和Guice框架有关，只运行一次，创建一个parent injector给所有guice injectors</td><td></td><td></td></tr><tr><td>guice-stage</td><td>和Guice框架有关</td><td>guice-stage=”DEVELOPMENT”</td><td>DEVELOPMENT，PRODUCTION，TOOL，默认”DEVELOPMENT”</td></tr><tr><td>configfailurepolicy</td><td>测试失败后是再次执行还是跳过，值skip和continue</td><td>configfailurepolicy=”skip”</td><td>skip、continue，默认skip</td></tr><tr><td>thread-count</td><td>与parallel配套使用，线程池的大小，决定并行线程数量</td><td>thread-count=”10”</td><td>整数，默认5</td></tr><tr><td>annotations</td><td>获取注解，值为javadoc时，使用JavaDoc的注释；否则用JDK5注释</td><td>annotations=”javadoc”</td><td>javadoc</td></tr><tr><td>time-out</td><td>设置parallel时，终止执行单元之前的等待时间（毫秒）</td><td>time-out=”10000”</td><td>整数，单位毫秒</td></tr><tr><td>skipfailedinvocationcounts</td><td>是否跳过失败的调用</td><td>skipfailedinvocationcounts=”true”</td><td>true和false，默认false</td></tr><tr><td>data-provider-thread-count</td><td>并发时data-provider的线程池数量</td><td>data-provider-thread-count=”5”</td><td>整数</td></tr><tr><td>object-factory</td><td>一个实现IObjectFactory接口的类，实例化测试对象</td><td>object-factory=”classname”</td><td>类名</td></tr><tr><td>allow-return-values</td><td>是否允许返回函数值</td><td>all-return-values=”true”</td><td>true和false</td></tr><tr><td>preserve-order</td><td>是否按照排序执行</td><td>preserve-order=”true”</td><td>true和false，默认true</td></tr><tr><td>group-by-instances</td><td>按照实例分组</td><td>group-by-instances=”true”</td><td>true和false，默认false</td></tr></tbody></table><p><strong>2.&lt;test&gt;</strong><br>一个&lt;suite&gt;下可以有多个&lt;test&gt;,&lt;test&gt;由&lt;parameters&gt;、&lt;groups&gt;、&lt;classes&gt;三部分组成,每个部分的作用如下：  </p><ul><li><p>&lt;parameter&gt; ： 提供测试数据，有name和value两个参数<br>声明方法：&lt;parameter name = “parameter_name” value = “parameter_value “/&gt;<br>testng.xml文件中的&lt;parameter&gt;可以声明在&lt;suite&gt;或者&lt;test&gt;级别，在&lt;test&gt;下的&lt;parameter&gt;会覆盖在&lt;suite&gt;下声明的同名变量。  </p></li><li><p>&lt;groups&gt;：要运行的组，可以自定义一个组，可以包括要执行的，和排除要执行的方法。必须和<classes>配套使用，从下面的类中找到对应名字的方法。  </classes></p></li><li><p>&lt;classes&gt;：方法选择器，要执行的方法写在这里，参数有name和priority，<br>&lt;classes&gt;下必须写要执行的&lt;class】&gt;，否则不会执行任何内容，如果填写了class没有写methods，会按照填写的class的下的注释@Test去执行所有的方法。</p></li></ul><p>&lt;test&gt;标签下也有很多参数，参数用法如下:  </p><table><thead><tr><th align="left">参数</th><th align="left">说明</th><th align="left">使用方法</th><th align="left">参数值</th></tr></thead><tbody><tr><td align="left">name</td><td align="left">test的名字，将出现在报告里</td><td align="left">name=”testname”</td><td align="left">test的名字</td></tr><tr><td align="left">junit</td><td align="left">是否按照Junit模式运行</td><td align="left">junit=”true”</td><td align="left">true和false，默认false</td></tr><tr><td align="left">verbose</td><td align="left">控制台输出的详细内容等级,0-10级（0无，10最详细），不在报告显示</td><td align="left">verbose=”5”</td><td align="left">0到10</td></tr><tr><td align="left">parallel</td><td align="left">是否在不同的线程并行进行测试，要与thread-count配套使用</td><td align="left">parallel=”mehods”</td><td align="left">与suite的parallel一致，默认false</td></tr><tr><td align="left">thread-count</td><td align="left">与parallel配套使用，线程池的大小，决定并行线程数量</td><td align="left">thread-count=”10”</td><td align="left">整数，默认5</td></tr><tr><td align="left">annotations</td><td align="left">获取注解，值为javadoc时，使用JavaDoc的注释；否则用JDK5注释</td><td align="left">annotations=”javadoc”</td><td align="left">javadoc</td></tr><tr><td align="left">time-out</td><td align="left">设置parallel时，终止执行单元之前的等待时间（毫秒）</td><td align="left">time-out=”10000”</td><td align="left">整数，单位毫秒</td></tr><tr><td align="left">enabled</td><td align="left">标记是否执行这个test</td><td align="left">enabled=”true”</td><td align="left">true和false，默认true</td></tr><tr><td align="left">skipfailedinvocationcounts</td><td align="left">是否跳过失败的调用</td><td align="left">skipfailedinvocationcounts=”true”</td><td align="left">true和false，默认false</td></tr><tr><td align="left">preserve-order</td><td align="left">是否按照排序执行，如果是true，将按照xml文件中的顺序去执行</td><td align="left">preserve-order=”true”</td><td align="left">true和false，默认true</td></tr><tr><td align="left">allow-return-values</td><td align="left">是否允许返回函数值</td><td align="left">all-return-values=”true”</td><td align="left">true和false，默认false</td></tr></tbody></table><p><strong>2.1&lt;group&gt;标签</strong><br>&lt;groups&gt;由&lt;difine&gt;和&lt;run&gt;、&lt;dependencies&gt;三部分组成。&lt;diffine&gt;可以将group组成一个新组，包括要执行和不执行的大组；&lt;run&gt;要执行的方法；&lt;dependencies&gt;指定了某group需要依赖的group.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;groups&gt;</span><br><span class="line">       &lt;define name &#x3D;&quot;all&quot;&gt;</span><br><span class="line">            &lt;include name &#x3D;&quot;testgroup1&quot;&#x2F;&gt;</span><br><span class="line">            &lt;exclude name &#x3D;&quot;testgroup2&#39;&#x2F;&gt;</span><br><span class="line">       &lt;&#x2F;define&gt;</span><br><span class="line">       &lt;run&gt;</span><br><span class="line">            &lt;include name &#x3D;&quot;all&quot;&#x2F;&gt;</span><br><span class="line">            &lt;include name &#x3D;&quot;testmethod1&quot;&#x2F;&gt;</span><br><span class="line">            &lt;exclude name&#x3D;&quot;testmethod2&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;run&gt;</span><br><span class="line">      &lt;dependencies&gt;</span><br><span class="line">           &lt;group name &#x3D;&quot;group1&quot; depends-on&#x3D;&quot;group2 group3&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;dependencies&gt;</span><br><span class="line"> &lt;&#x2F;groups&gt;  </span><br><span class="line"> </span><br></pre></td></tr></table></figure>  ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当使用TestNG来运行测试用例时，一个典型的步骤为： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编写测试业务逻辑代码并添加TestNG的注解&lt;/li&gt;
&lt;li&gt;在testng.xml配置测试信息&lt;/li&gt;
&lt;li&gt;运行TestNG  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个xml文件在这里就起到了关键作用。举个例子来说：在做菜的时候我们可能会去看菜谱，菜谱会告诉我们要放哪些调料，以及放的顺序。但是我们也可以按照我们自己的需求来修改菜谱，也就是说最后的菜是按照自定义的配置做出来的。如果将自动化测试类比为做菜的过程，那么xml文件在这里的作用就是按照需求去自定义配置菜谱的过程。最后测试用例就是按照我们的配置来运行。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="TestNG" scheme="http://yoursite.com/tags/TestNG/"/>
    
  </entry>
  
  <entry>
    <title>TestNG并发</title>
    <link href="http://yoursite.com/2020/05/21/TestNG%E5%B9%B6%E5%8F%91/"/>
    <id>http://yoursite.com/2020/05/21/TestNG%E5%B9%B6%E5%8F%91/</id>
    <published>2020-05-21T05:27:08.000Z</published>
    <updated>2020-06-05T02:10:21.650Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lt-suite-gt-级别的并发"><a href="#lt-suite-gt-级别的并发" class="headerlink" title="&lt;suite&gt;级别的并发"></a>&lt;suite&gt;级别的并发</h4><p>TestNG在&lt;suite&gt;级别的并发主要由parallel参数来决定，且该参数要和thread-count配合使用，否则没有意义。<br>一共有如下四种不同的并发:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;suite name&#x3D;&quot;Testng Parallel Test&quot; parallel&#x3D;&quot;methods&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;Testng Parallel Test&quot; parallel&#x3D;&quot;tests&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;Testng Parallel Test&quot; parallel&#x3D;&quot;classes&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;Testng Parallel Test&quot; parallel&#x3D;&quot;instances&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br></pre></td></tr></table></figure><p><strong>1.methods级别的并发</strong>，TestNG将在单独的线程中运行所有测试方法<br>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class testXml &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;testXml的test1运行&quot; + &quot; &quot;+ &quot;Current Thread Id: &quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;testXml的test2运行&quot; + &quot; &quot;+ &quot;Current Thread Id: &quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>testNG.xml文件设置如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;suite name&#x3D;&quot;testXml&quot; parallel&#x3D;&quot;methods&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br></pre></td></tr></table></figure><p>测试结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testXml的test1运行 Current Thread Id: 11</span><br><span class="line">testXml的test2运行 Current Thread Id: 12</span><br></pre></td></tr></table></figure><p><strong>2.tests级别的并发</strong>，相同test tag下的测试case将会在同一个进程中运行，不同test tag 下的测试case会在不同的进程中运行。<br>举个例子:<br>test1和test2仍然在同一份test tag下，将并发参数改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;suite name&#x3D;&quot;Testng Parallel Test&quot; parallel&#x3D;&quot;tests&quot; thread-count&#x3D;&quot;5&quot;&gt;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testXml的test1运行 Current Thread Id: 11</span><br><span class="line">testXml的test2运行 Current Thread Id: 11</span><br></pre></td></tr></table></figure><p>再将test1和test2分别放在不同的test tag下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;suite name&#x3D;&quot;testXml&quot; parallel&#x3D;&quot;tests&quot; thread-count&#x3D;&quot;5&quot;  &gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;test1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.testXml&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line">                    &lt;include name&#x3D;&quot;test1&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line"></span><br><span class="line">    &lt;test name&#x3D;&quot;test2&quot;&gt;</span><br><span class="line">    &lt;classes&gt;</span><br><span class="line">        &lt;class name&#x3D;&quot;org.example.testXml&quot;&gt;</span><br><span class="line">            &lt;methods&gt;</span><br><span class="line">                &lt;include name&#x3D;&quot;test2&quot;&#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;methods&gt;</span><br><span class="line">        &lt;&#x2F;class&gt;</span><br><span class="line">    &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">testXml的test2运行 Current Thread Id: 12</span><br><span class="line">testXml的test1运行 Current Thread Id: 11</span><br></pre></td></tr></table></figure><p><strong>3.class级别的并发</strong>，不同class tag下的用例可以在不同的线程执行，相同class tag下的用例只能在同一个线程中执行<br>举个例子：<br>引入testXml2的测试case，testNG.xml的文件变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;suite name&#x3D;&quot;testXml&quot; parallel&#x3D;&quot;classes&quot; thread-count&#x3D;&quot;5&quot;  &gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;test1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.testXml&quot;&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.testXml2&quot;&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">testXml的test1运行 Current Thread Id: 11</span><br><span class="line">testXml2的test1运行 Current Thread Id: 12</span><br><span class="line">testXml2的test2运行 Current Thread Id: 12</span><br><span class="line">testXml的test2运行 Current Thread Id: 11</span><br></pre></td></tr></table></figure><p><strong>4.instance级别的并发</strong>，同一个实例的方法将会在同一个线程中运行，不同实例的方法将会在不同线程中运行。<br>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class testParallel1 &#123;</span><br><span class="line">    public int i;</span><br><span class="line">    public testParallel1(int i) &#123;this.i &#x3D; i;&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;testXml的test1运行&quot; + &quot; &quot;+ &quot;Current Thread Id: &quot; + Thread.currentThread().getId() + &quot;第&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Factory</span><br><span class="line">    public static Object[] create()</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;testParallel1&gt; list &#x3D; new ArrayList&lt;testParallel1&gt;();</span><br><span class="line">        list.add(new testParallel1(1));</span><br><span class="line">        list.add(new testParallel1(2));</span><br><span class="line">        list.add(new testParallel1(3));</span><br><span class="line">        return list.toArray();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，一个测试用例，三个参数，共三个用例，每个用例都是一个实例。所以应该有三个并发。<br>如果是没有@Factory注解的普通用例，则没效果。<br>运行结果为：<br><img src="/2020/05/21/TestNG%E5%B9%B6%E5%8F%91/result_instance.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">testXml的test1运行 Current Thread Id: 13第2</span><br><span class="line">testXml的test1运行 Current Thread Id: 12第1</span><br><span class="line">testXml的test1运行 Current Thread Id: 11第3</span><br></pre></td></tr></table></figure><p>可以看到，在这种并发模式下每个不同的实例都会在不同的线程中运行。  </p><h4 id="用例级别的并发"><a href="#用例级别的并发" class="headerlink" title="用例级别的并发"></a>用例级别的并发</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class testParallel1 &#123;</span><br><span class="line">    &#x2F;&#x2F;线程数为3，调用次数为6，超时时间为1000ms</span><br><span class="line">    @Test(threadPoolSize &#x3D; 3 , invocationCount &#x3D; 6 , timeOut &#x3D; 1000)</span><br><span class="line">    public void test1()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;testXml的test1运行&quot; + &quot; &quot;+ &quot;Current Thread Id: &quot; + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">testXml的test1运行 Current Thread Id: 16</span><br><span class="line">testXml的test1运行 Current Thread Id: 15</span><br><span class="line">testXml的test1运行 Current Thread Id: 14</span><br><span class="line">testXml的test1运行 Current Thread Id: 15</span><br><span class="line">testXml的test1运行 Current Thread Id: 16</span><br><span class="line">testXml的test1运行 Current Thread Id: 14</span><br></pre></td></tr></table></figure><p>在这个例子里面，通过invocationCount设置test1方法的调用次数，通过threadPoolSize设置启用的线程数。从结果看到，test1被调用6次，总共在3个线程里面运行，和设置的参数一致。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;lt-suite-gt-级别的并发&quot;&gt;&lt;a href=&quot;#lt-suite-gt-级别的并发&quot; class=&quot;headerlink&quot; title=&quot;&amp;lt;suite&amp;gt;级别的并发&quot;&gt;&lt;/a&gt;&amp;lt;suite&amp;gt;级别的并发&lt;/h4&gt;&lt;p&gt;TestNG在&amp;lt;suite&amp;gt;级别的并发主要由parallel参数来决定，且该参数要和thread-count配合使用，否则没有意义。&lt;br&gt;一共有如下四种不同的并发:&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="TestNG" scheme="http://yoursite.com/tags/TestNG/"/>
    
  </entry>
  
  <entry>
    <title>TestNG常见注解</title>
    <link href="http://yoursite.com/2020/05/20/TestNG%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/20/TestNG%E5%B8%B8%E8%A7%81%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-20T03:30:33.000Z</published>
    <updated>2020-06-05T02:10:21.638Z</updated>
    
    <content type="html"><![CDATA[<p>TestNG是一个开源的自动化测试框架, NG表示Next Generation。TestNG类似于JUnit（尤其是JUnit4），但它不是JUnit的扩展。它的灵感来自JUnit但是设计优于JUnit，尤其是在测试集成类时。TestNG有强大的注解功能，下面将利用小demo来展示常用的注解及用法。</p><a id="more"></a><p><strong>@Test：</strong> 最基本的注解，用来把方法标记为测试的一部分</p><p><strong>@BeforeSuite：</strong> 对于套件测试，在此套件中的所有测试执行之前运行，仅运行一次<br><strong>@AfterSuite：</strong> 对于套件测试，在此套件中的所有测试执行之后运行，仅运行一次<br>例子:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationSuite &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;System.out.print(&quot;test1运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;System.out.print(&quot;test2运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;System.out.print(&quot;test3运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @BeforeSuite</span><br><span class="line">    public void beforeSuite() &#123;System.out.println(&quot;BeforeSuite运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @AfterSuite</span><br><span class="line">    public void afterSuite()&#123;System.out.println(&quot;AfterSuite运行&quot;);&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的XML文件如下: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testSuite&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;annotation1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.annotation.AnnotationSuite&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br></pre></td></tr></table></figure>  <p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeforeSuite运行</span><br><span class="line">test1运行</span><br><span class="line">test2运行</span><br><span class="line">test3运行</span><br><span class="line">AfterSuite运行</span><br></pre></td></tr></table></figure><p><strong>@BeforeTest：</strong> 对于套件测试，在属于<test>标签内的所有类的测试方法执行之前运行<br><strong>@AfterTest：</strong> 对于套件测试，在属于<test>标签内的所有类的测试方法都已执行完之后运行<br>例子：   </test></test></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationTest &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;System.out.print(&quot;test1运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;System.out.print(&quot;test2运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;System.out.print(&quot;test3运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @BeforeTest</span><br><span class="line">    public void beforeTest()&#123;System.out.println(&quot;BeforeTest运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @AfterTest</span><br><span class="line">    public void afterTest()&#123; System.out.println(&quot;AfterTest运行&quot;);&#125;</span><br></pre></td></tr></table></figure>   <p>对应的XML文件为  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testTest&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;annotationTest1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.annotation.AnnotationTest&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line">                    &lt;include name&#x3D;&quot;test1&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;include name&#x3D;&quot;test3&quot;&#x2F;&gt;</span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line"></span><br><span class="line">        &lt;test name&#x3D;&quot;annotationTest2&quot;&gt;</span><br><span class="line">            &lt;classes&gt;</span><br><span class="line">                &lt;class name&#x3D;&quot;org.example.annotation.AnnotationTest&quot;&gt;</span><br><span class="line">                    &lt;methods&gt;</span><br><span class="line">                        &lt;include name&#x3D;&quot;test2&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;methods&gt;</span><br><span class="line">                &lt;&#x2F;class&gt;</span><br><span class="line">            &lt;&#x2F;classes&gt;</span><br><span class="line">        &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>   <p>运行结果为:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BeforeTest运行</span><br><span class="line">test1运行</span><br><span class="line">test3运行</span><br><span class="line">AfterTest运行</span><br><span class="line"></span><br><span class="line">BeforeTest运行</span><br><span class="line">test2运行</span><br><span class="line">AfterTest运行</span><br></pre></td></tr></table></figure>   <p>注意：从运行结果可以看到@BeforeTest和@AfterTest针对的是xml文件中的test标签来决定是否运行，而不是测试用例上面的@test。因此如果有多个测试用例，但在xml文件中只有一个test标签，那么@BeforeTest和@AfterTest也只分别运行一次。</p><p><strong>@BeforeClass：</strong> 在调用当前类之前运行<br><strong>@AfterClass：</strong> 在调用当前类之后运行<br>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ublic class AnnotationClass &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123;System.out.print(&quot;test1运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;System.out.print(&quot;test2运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;System.out.print(&quot;test3运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @BeforeClass</span><br><span class="line">    public void beforeClass()&#123;System.out.println(&quot;BeforeClass运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @AfterClass</span><br><span class="line">    public void afterClass()&#123;System.out.println(&quot;AfterClass运行&quot;);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>对应的XML文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testClass&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;annotationClass1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.annotation.AnnotationClass&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>运行结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BeforeClass运行</span><br><span class="line">test1运行</span><br><span class="line">test2运行</span><br><span class="line">test3运行</span><br><span class="line">AfterClass运行  </span><br></pre></td></tr></table></figure> <p><strong>@BeforeMethod：</strong> 在每个测试方法执行之前都会运行<br><strong>@AfterMethod：</strong> 在每个测试方法执行之后都会运行<br>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationMethod &#123;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test1() &#123; System.out.print(&quot;test1运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test2() &#123;System.out.print(&quot;test2运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test3()&#123;System.out.print(&quot;test3运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @BeforeMethod</span><br><span class="line">    public void beforeMethod()&#123;System.out.println(&quot;BeforeMethod运行&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @AfterMethod</span><br><span class="line">    public void afterMethod()&#123;System.out.println(&quot;AfterMethod运行&quot;);&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对应的XML文件为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testMethod&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;annotationTest1&quot;&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.annotation.AnnotationMethod&quot;&gt;</span><br><span class="line">                &lt;methods&gt;</span><br><span class="line">                &lt;&#x2F;methods&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br></pre></td></tr></table></figure><p>运行结果：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BeforeMethod运行</span><br><span class="line">test1运行</span><br><span class="line">AfterMethod运行</span><br><span class="line"></span><br><span class="line">BeforeMethod运行</span><br><span class="line">test2运行</span><br><span class="line">AfterMethod运行</span><br><span class="line"></span><br><span class="line">BeforeMethod运行</span><br><span class="line">test3运行</span><br><span class="line">AfterMethod运行</span><br></pre></td></tr></table></figure><p><strong>@BeforeGroups：</strong> 在调用属于该组的第一个测试方法之前运行<br><strong>@AfterGroups：</strong> 在调用属于该组的最后一个测试方法执行之后运行<br>例子：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AnnotationGroups &#123;</span><br><span class="line"></span><br><span class="line">    @Test(groups &#x3D; &#123; &quot;group1&quot;, &quot;group2&quot; &#125;)</span><br><span class="line">    public void test1() &#123;System.out.println(&quot;test1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test(groups &#x3D; &#123;&quot;group1&quot;, &quot;group2&quot;&#125; )</span><br><span class="line">    public void test2() &#123;System.out.println(&quot;test2&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test(groups &#x3D; &#123; &quot;group1&quot; &#125;)</span><br><span class="line">    public void test3() &#123;System.out.println(&quot;test3&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @BeforeGroups(&quot;group1&quot;)</span><br><span class="line">    public void beforeGroups()&#123;System.out.println(&quot;BeforeGroups&quot;);&#125;</span><br><span class="line"></span><br><span class="line">    @AfterGroups(&quot;group2&quot;)</span><br><span class="line">    public void afterGroups()&#123;System.out.println(&quot;AfterGroups&quot;);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <p>对应的XML文件为：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testGroup&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;group&quot;&gt;</span><br><span class="line">        &lt;groups&gt;</span><br><span class="line">            &lt;run&gt;</span><br><span class="line">                &lt;include name&#x3D;&quot;group1&quot; &#x2F;&gt;</span><br><span class="line">                &lt;include name&#x3D;&quot;group2&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;run&gt;</span><br><span class="line">        &lt;&#x2F;groups&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.annotation.AnnotationGroups&quot;&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <p>运行结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BeforeGroups</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">AfterGroups</span><br><span class="line"></span><br><span class="line">test3</span><br></pre></td></tr></table></figure><p><strong>@Parameters：</strong> 描述如何将参数传递给@Test方法。<br>例子：   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class testParameter &#123;</span><br><span class="line">    @Test</span><br><span class="line">    @Parameters(value &#x3D; &quot;str1&quot;)</span><br><span class="line">    public void test1(String str)&#123;System.out.println(str);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的XML文件为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE suite SYSTEM &quot;http:&#x2F;&#x2F;testng.org&#x2F;testng-1.0.dtd&quot; &gt;</span><br><span class="line">&lt;suite name&#x3D;&quot;testParameter&quot;&gt;</span><br><span class="line">    &lt;test name&#x3D;&quot;login&quot;&gt;</span><br><span class="line">        &lt;parameter name&#x3D;&quot;str1&quot; value&#x3D;&quot;通过@test下面的@Paremeter传参数&quot;&gt;&lt;&#x2F;parameter&gt;</span><br><span class="line">        &lt;classes&gt;</span><br><span class="line">            &lt;class name&#x3D;&quot;org.example.parameter.testParameter&quot;&gt;</span><br><span class="line">            &lt;&#x2F;class&gt;</span><br><span class="line">        &lt;&#x2F;classes&gt;</span><br><span class="line">    &lt;&#x2F;test&gt;</span><br><span class="line">&lt;&#x2F;suite&gt;</span><br></pre></td></tr></table></figure><p>运行结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过@test下面的@Paremeter传参数</span><br></pre></td></tr></table></figure><p>当参数类型较为复杂时，上述的传参方法无法满足需要，此时可以利用@DataProvider传参。该方法会返回一个Object二维数组或一个Iterator&lt;Object[]&gt;来提供复杂的参数对象。Object[][]这个二维数组的每一个一维数组代表一个对象。这个一维数组中的元素类型，个数必须和使用这个provider的函数的参数匹配。使用这个Provider的Method会遍历Provider传递过来的每一个对象，每个对象都执行一次方法体内的代码。所以Object[][]第一个参数指定了@Test标识的test method被执行的次数。  </p><p><strong>@DataProvider：</strong> 标记一种方法来提供测试方法的数据。 注释方法必须返回一个Object [] []，其中每个Object []可以被分配给测试方法的参数列表。<br>例子：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class testDataProvider &#123;</span><br><span class="line">    @DataProvider(name &#x3D; &quot;inDp&quot;)</span><br><span class="line">    public Object[][] createData1() &#123;</span><br><span class="line">        return new Object[][] &#123;</span><br><span class="line">                &#123; &quot;通过内部DataProvider传参1&quot;, new Integer(36) &#125;,</span><br><span class="line">                &#123; &quot;通过内部DataProvider传参2&quot;, new Integer(37)&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    @Test(dataProvider &#x3D; &quot;inDp&quot;)</span><br><span class="line">    public void test3(String n1, Integer n2) &#123;</span><br><span class="line">        System.out.println(n1 + &quot; &quot; + n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <p>运行结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过内部DataProvider传参1 36</span><br><span class="line">通过内部DataProvider传参2 37</span><br></pre></td></tr></table></figure><p>如果测试用例和DataProvider不在同一个类中，那么需要将返回参数值的函数标记为static。<br>例子： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class StaticProvider &#123;</span><br><span class="line">    @DataProvider(name &#x3D; &quot;outDp&quot;)</span><br><span class="line">    public static Object[][] createData() &#123;</span><br><span class="line">        return new Object[][] &#123;</span><br><span class="line">                &#123; &quot;通过外部DataProvider传参&quot;, new Integer(&quot;1&quot;) &#125;,</span><br><span class="line">                &#123;&quot;通过外部DataProvider传参&quot;, new Integer(&quot;2&quot;)&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">调用过程为：</span><br><span class="line">@Test(dataProvider &#x3D; &quot;outDp&quot;, dataProviderClass &#x3D; StaticProvider.class)</span><br><span class="line">    public void test4(String str1,Integer i)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(str1 + &quot; &quot; + i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>  <p>运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过外部DataProvider传参 1</span><br><span class="line">通过外部DataProvider传参 2</span><br></pre></td></tr></table></figure> <p>除此之外还可以使用迭代器进行传参数，例子如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> @DataProvider(name &#x3D; &quot;iteratorDataProvider&quot;)</span><br><span class="line">    public Iterator&lt;Object[]&gt; iteratorDataProvider()&#123;</span><br><span class="line">        List&lt;Object[]&gt; objList &#x3D; new ArrayList&lt;Object[]&gt;();</span><br><span class="line">        for(int i &#x3D; 1; i &lt; 5; i++)&#123;</span><br><span class="line">            objList.add(new Object[]&#123;&quot;第&quot; + i  + &quot;名得分&quot;, new Integer(i) ,&quot;哈哈&quot;&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        return objList.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">    @Test(dataProvider &#x3D; &quot;iteratorDataProvider&quot;)</span><br><span class="line">    public void testDataProvider(String str, Integer i, String str2)&#123;</span><br><span class="line">        System.out.println(str+i+str2);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">第1名得分1哈哈</span><br><span class="line">第2名得分2哈哈</span><br><span class="line">第3名得分3哈哈</span><br><span class="line">第4名得分4哈哈</span><br></pre></td></tr></table></figure>  <p>因此使用DataProvider传递参数时，返回的参数个数和类型应与调用这个provider的函数所需要的参数个数和类型完全匹配。</p><p>以上便是TestNGINX常用的一些注解，后面若学习到新的注解会继续补充~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TestNG是一个开源的自动化测试框架, NG表示Next Generation。TestNG类似于JUnit（尤其是JUnit4），但它不是JUnit的扩展。它的灵感来自JUnit但是设计优于JUnit，尤其是在测试集成类时。TestNG有强大的注解功能，下面将利用小demo来展示常用的注解及用法。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="TestNG" scheme="http://yoursite.com/tags/TestNG/"/>
    
  </entry>
  
  <entry>
    <title>项目小结-2020/4/3</title>
    <link href="http://yoursite.com/2020/04/13/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93-2020-4-3/"/>
    <id>http://yoursite.com/2020/04/13/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93-2020-4-3/</id>
    <published>2020-04-13T01:16:05.000Z</published>
    <updated>2020-06-05T02:10:21.691Z</updated>
    
    <content type="html"><![CDATA[<p>再有三个月我就加入公司两年了，时间过的真的非常快。自从加入公司后我便一直在这个项目上，时间长了，有一种自己就是工作于当前项目公司的员工，所以第一次听到项目要结束时便产生了一些失落感，仿佛不久之后自己也要失业了。但由于项目很大，所以真正结束也需要很长的一段时间。然而谁也没有想到这次席卷全球的“黑天鹅”事件竟然匆匆忙忙就结束了项目，真的是人算不如天算。一年七个月有很多收获，我想把他们记录下来，不论是做的好的地方还是做的不好的地方，希望给以后的自己留下一些积累。</p><a id="more"></a><h3 id="敏捷实践"><a href="#敏捷实践" class="headerlink" title="敏捷实践"></a>敏捷实践</h3> <img src="/2020/04/13/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93-2020-4-3/敏捷实践.png">   真正上了项目以后才知道敏捷实践是怎么做的，以及它们在我们日常工作中的重要性。上图记录了我的日常工作，以及收获和反思。<h3 id="测试技能"><a href="#测试技能" class="headerlink" title="测试技能"></a>测试技能</h3><img src="/2020/04/13/%E9%A1%B9%E7%9B%AE%E5%B0%8F%E7%BB%93-2020-4-3/测试.png">  测试这一块包含的东西特别多，图中基本涵盖了大部分的工作，但是没有特别多的细节。对于FT，项目主要采用了selenium+web driver的框架来开展测试。而代码则是基于page object的模式来编写。之前我只知道这样子去编写代码，但是没有深入了解这种编码模式的好处。直到前一段时间，自己利用page object模式编写了简单代码后才真正了解了这种编码形式的好处。这一块的内容仍然需要继续深入学习。<h3 id="客户影响力"><a href="#客户影响力" class="headerlink" title="客户影响力"></a>客户影响力</h3><p>在团队内部我觉得自己算是很活跃的一份子，但依然会觉得对于客户的影响力不够。我也思考过其中的原因：<br>1.自身能力不够强，缺乏足够的说服力<br>2.上项目时间仍然很短，虽然我是小组的QA，但是因为有时间更长的tribe QA在，所以会在我的基础上参考tribe QA的观点<br>关于客户影响力，我始终觉得这是一个不好量化的能力，什么样是客户影响力高？大多数观点都被采纳就是影响力高么？在项目匆忙结束下我竟然忘了向团队成员们要feedback,这个点确实是有点失误。也许要了feedback我能知道一下答案吧。这个问题只能留给以后的我去解答了。</p><h3 id="同事相处"><a href="#同事相处" class="headerlink" title="同事相处"></a>同事相处</h3><p>感觉自己是很幸运的，因为团队的人都非常nice，即使他们中有的都已经工作了十年+，但是对于我这个一毕业就加入他们的小白没有任何看轻的意思。非常感谢他们，我在工作以后仍然有和同学相处的感觉，不必为了同事之间的关系而烦恼。不知道以后会遇到什么样的同事，希望能够友好相处。 </p><p>现在正处于等待项目的空闲期，可以好好充实自己为下一个项目做好准备。继续加油啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再有三个月我就加入公司两年了，时间过的真的非常快。自从加入公司后我便一直在这个项目上，时间长了，有一种自己就是工作于当前项目公司的员工，所以第一次听到项目要结束时便产生了一些失落感，仿佛不久之后自己也要失业了。但由于项目很大，所以真正结束也需要很长的一段时间。然而谁也没有想到这次席卷全球的“黑天鹅”事件竟然匆匆忙忙就结束了项目，真的是人算不如天算。一年七个月有很多收获，我想把他们记录下来，不论是做的好的地方还是做的不好的地方，希望给以后的自己留下一些积累。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="敏捷实践" scheme="http://yoursite.com/tags/%E6%95%8F%E6%8D%B7%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>基于Page Object的Appium测试实例改进</title>
    <link href="http://yoursite.com/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/"/>
    <id>http://yoursite.com/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/</id>
    <published>2020-03-27T11:37:26.000Z</published>
    <updated>2020-06-05T02:10:21.684Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间我在极客时间上订阅了Mobile测试的相关课程，在学习了一些基础知识后，跟着老师以及网上的教程搭建了基于MAC的appium运行环境，并在此基础上使用appium的record功能生成了测试Android app的第一个例子。由于实际中record功能使用的并不多，因此我跟着视频进行了下一步的测试改进。</p><a id="more"></a><p>首先下载Android Studio和IDEA，加上appium，这三者的作用分别为：  </p><ul><li>appium – server   </li><li>IDEA – client  </li><li>Android Studio – 手机模拟器   </li></ul><p>打开IDEA将之前record生成的代码拷贝进去，并添加相应的依赖和包，运行后测试用例通过。该测试用例完成的动作是打开雪球app，关闭弹窗后点击搜索框并输入alibaba，代码如下：  </p><pre><code>import io.appium.java_client.MobileElement;import io.appium.java_client.android.AndroidDriver;import junit.framework.TestCase;import org.junit.After;import org.junit.Before;import org.junit.Test;import java.net.MalformedURLException;import java.net.URL;import org.openqa.selenium.remote.DesiredCapabilities;public class SampleTest {private AndroidDriver driver;@Beforepublic void setUp() throws MalformedURLException {    DesiredCapabilities desiredCapabilities = new DesiredCapabilities();    desiredCapabilities.setCapability(&quot;platformName&quot;, &quot;android&quot;);    desiredCapabilities.setCapability(&quot;deviceName&quot;, &quot;test&quot;);    desiredCapabilities.setCapability(&quot;appPackage&quot;, &quot;com.xueqiu.android&quot;);    desiredCapabilities.setCapability(&quot;appActivity&quot;, &quot;.view.WelcomeActivityAlias&quot;);    desiredCapabilities.setCapability(&quot;autoGrantPermissions&quot;, &quot;true&quot;);    URL remoteUrl = new URL(&quot;http://localhost:4723/wd/hub&quot;);    driver = new AndroidDriver(remoteUrl, desiredCapabilities);}@Testpublic void sampleTest() {    MobileElement el1 = (MobileElement) driver.findElementById(&quot;com.xueqiu.android:id/tv_search&quot;);    el1.click();    MobileElement el2 = (MobileElement) driver.findElementById(&quot;com.xueqiu.android:id/search_input_text&quot;);    el2.sendKeys(&quot;alibaba&quot;);}@Afterpublic void tearDown() {    driver.quit();}}</code></pre><p>这是一个非常简单的例子，从代码中可以看到，无论是测试开始前driver的初始化还是页面元素的查找和操作以及最后driver的关闭都集中写在一个文件中。如果增加多个这样的文件，那么每一个文件都要增加driver初始化和关闭的代码，并且每一次页面的元素发生变化那么用到该元素的文件均需要做出改变。这种代码是极其脆弱且难以维护的。那么有没有什么方法可以解决上述问题呢？  </p><p>答案是有！早在2013年，软件大师Martin Fowler就写下了Page Object的文章，他认为应该用Page Object的模式来构建自动化测试代码。Page Object的一个基本经验法则是凡是人类能做的事page object通过软件客户端都能够做到。它也应当提供一个易于编程的接口并隐藏窗口中底层的部件。也就是说可以使用Page Object来封装一个html页面或部分页面，测试人员通过Page Object提供的应用程序特定的API接口来操作页面元素，而不需要在在原来的HTML页面中直接寻找你、和操作元素。这样做的好处是：</p><ul><li>减少代码的重复  </li><li>提高测试用例的可读性  </li><li>提高测试用例的可维护性  </li></ul><p>下面这张图描述了一般基于Page Object模式测试代码各个模块的作用</p><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/POM.png" width="60%" height="60%"> <p>从上图可以知道，基于Page Object model的测试用例组织结构中，每一部分都有其专门的作用。例如page用来对页面进行封装，而不用来进行其他的操作；driver只用来驱动各种接口；testcase只用来写测试用例。下面我们按照该结构来更改这个简单的测试用例。  </p><h4 id="–第0步–："><a href="#–第0步–：" class="headerlink" title="–第0步–："></a>–第0步–：</h4><p>driver初始化动作以及测试case都写在一个文件上：demo.java   </p><h4 id="–第1步–："><a href="#–第1步–：" class="headerlink" title="–第1步–："></a>–第1步–：</h4><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/first_step.png" width="80%" height="80%">  <p>创建BasePage来管理driver，把driver的代码挪到BasePage.java，在该class文件中构造setup()函数，返回driver。在demo.java中增加原函数的构造函数，利用构造函数初始化driver。此时只把driver的初始化代码挪出去，而到首页以及点击搜索和搜索阿里巴巴的代码仍然留在demo.java中。  </p><h4 id="–第2步–："><a href="#–第2步–：" class="headerlink" title="–第2步–："></a>–第2步–：</h4><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/second_step.png" width="80%" height="80%">  <p>创建BaseMainPage.java，将点击搜索从而到达search页面的代码挪到BaseMainPage.java中。创建BaseSearchPage.java，将点击搜索框和输入阿里巴巴的代码挪到BaseSearchPage.java中。此时demo.java中只剩下初始化BasePage，BaseMainPage，BaseSearchPage的代码，其中demo.java的构造函数拿到BasePage初始化的driver，BaseMainPage，BaseSearchPage分别拿到driver后调用GoToSearchPage(driver)和Search(driver,”alibaba”)。这个时候的代码虽然已有page object 的模式，但是可以看到，driver还是暴露在demo.java文件中，这样是不合理的。因为page object模式的初衷就是为了隐藏底层代码。</p><h4 id="–第3步–："><a href="#–第3步–：" class="headerlink" title="–第3步–："></a>–第3步–：</h4><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/third_step.png" width="80%" height="80%">  <p>改变BasePage.java的返回值，使其不再返回driver而是返回进入app后的主页面，这一步骤相当于是返回了带有初始化的driver的主页面。因此不需要再在demo.java中再次初始化BaseMainPage，给其初始化的driver。以此类推，在BaseMainPage.java中的GoToSearchPage方法也可以返回初始化的driver的search page。这样以后在demo.java页面中只需要初始化BasePage,并且调用相应的函数就能够一次得到初始化的Main page和search page</p><h4 id="–第4步–："><a href="#–第4步–：" class="headerlink" title="–第4步–："></a>–第4步–：</h4><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/fourth_step.png" width="80%" height="80%">  <p>把关闭server的代码也放到BasePage里面</p><h4 id="–第5步–："><a href="#–第5步–：" class="headerlink" title="–第5步–："></a>–第5步–：</h4><img src="/2020/03/27/%E5%9F%BA%E4%BA%8EPage%20Object%E7%9A%84Appium%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B%E6%94%B9%E8%BF%9B/fifth_step.png" width="60%" height="60%">  <p>新建BaseBasePage，并创建driver， 使BaseMainPage和BaseSearchPage继承该page，从而这两个page不需要再次创建自己的driver。封装FindElementById方法，将其写入BaseBasePage中，从而继承它的类都可以直接调用该方法。</p><p>经过5步后就形成了基本的page object模式。但这还只是一个简单的例子，不涉及到data以及其他的一些配置文件，这些需要根据项目的需要进一步改进。在使用Page Object时候有以下需要注意的地方：</p><ul><li>public方法代表Page提供的功能</li><li>尽量不要暴露Page的内部细节</li><li>不要assertion</li><li>方法可以返回其他Page Objects</li><li>Page Objects不用代表整个页面，可以是任意一个部分</li><li>一样的操作，不同的结果应该分开（正确登录，错误登录）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间我在极客时间上订阅了Mobile测试的相关课程，在学习了一些基础知识后，跟着老师以及网上的教程搭建了基于MAC的appium运行环境，并在此基础上使用appium的record功能生成了测试Android app的第一个例子。由于实际中record功能使用的并不多，因此我跟着视频进行了下一步的测试改进。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Appium" scheme="http://yoursite.com/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>基于Appium的简单Mobile测试实例</title>
    <link href="http://yoursite.com/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-03-07T11:57:14.000Z</published>
    <updated>2020-06-05T02:10:21.661Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的学习中已经搭好了基于MAC的Appium Desktop平台，在此基础上利用appium来做一个简单的测试例子。由于appium测试的模式是CS模式，client发起请求，server接收到该请求后来操作待测试的app。因此测试实例需要有client，server，app。这里server就是appium desktop，app利用Android studio提供的模拟器中的app，最后client就是我们写的测试代码。</p><a id="more"></a><p>appium desktop其实本身就包含server和client，因此在用测试代码来测试app之前，先利用appium desktop来完成简单的测试功能。打开appium界面后可以看到右下角有一个start session按钮。其实对于appium来说，启动模拟器并与之进行通信的这个过程叫做session，但是如果直接点击start session按钮，会提示下图的错误信息:  </p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/start session1.png" width="80%" height="80%">  <p>该错误的意思是说在在start session之前需要提供platformName这个参数，由于此次测试用到Android模拟器因此这里可以将platformName设置为android，此时继续点击start session又会提示新的错误信息。按照这样的步骤可以发现对于Android设备，在start session之前需要设置的参数有：</p><ul><li>platformName-表示测试的是什么系统，包括iOS, Android, FirefoxOS</li><li>deviceName-表示使用的移动设备或模拟器的种类，对于iOS设备，必须是有效的手机型号。对于Android设备，该参数虽然必填但是可以输入任意的参数</li><li>appPackage-表示被测试的app的Java包</li><li>appActivity-表示想要启动的app的包  </li></ul><p>这里被测试的app是雪球，因此实例需要用到的参数如下图：  </p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/start session2.png" width="80%" height="80%"> <p>再次点击start session可以发现session被成功启动：</p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/start session3.png" width="80%" height="80%"> <p>下面先利用desktop的录制功能来进行实例演练。点击下图所示的“眼睛”即可开始录制，然后选中搜索框元素，点击Tap,接着再次点击搜索框元素，点击Sendkeys，输入alibaba。 </p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/record2.gif" width="80%" height="80%">   <p>此时看模拟器，发现模拟器也停留在搜索alibaba的界面上。</p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/record3.png" width="30%" height="50%"> <p>在录制的同时也生成了对应的代码，把这部分代码保存下来，利用代码来实现这个测试用例。<br><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/record4.png" width="80%" height="80%"> </p><p>打开IDEA，新建一个gradle工程，把之前保存下来的代码贴进去，添加appium和selenium依赖。  </p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/IDEA1.png" width="80%" height="80%"> <p>此时发现代码依然报错，主要是导入的包都不能正确加载。在网上搜索解决方案后，发现解决办法是：打开project structure，点击Modules，点击Dependencies,然后把包加载进来，并把包最右边的选项改为complie。在此之后代码便可以顺利运行。</p><img src="/2020/03/07/%E5%9F%BA%E4%BA%8EAppium%E7%9A%84%E7%AE%80%E5%8D%95Mobile%E6%B5%8B%E8%AF%95%E5%AE%9E%E4%BE%8B/IDEA2.png" width="80%" height="80%"> <p>代码为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import io.appium.java_client.MobileElement;</span><br><span class="line">import io.appium.java_client.android.AndroidDriver;</span><br><span class="line">import junit.framework.TestCase;</span><br><span class="line">import org.junit.After;</span><br><span class="line">import org.junit.Before;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import java.net.MalformedURLException;</span><br><span class="line">import java.net.URL;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">import org.openqa.selenium.remote.DesiredCapabilities;</span><br><span class="line"></span><br><span class="line">public class demo1 &#123;</span><br><span class="line"></span><br><span class="line">    private AndroidDriver driver;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws MalformedURLException &#123;</span><br><span class="line">        DesiredCapabilities desiredCapabilities &#x3D; new DesiredCapabilities();</span><br><span class="line">        desiredCapabilities.setCapability(&quot;platformName&quot;, &quot;android&quot;);</span><br><span class="line">        desiredCapabilities.setCapability(&quot;deviceName&quot;, &quot;test&quot;);</span><br><span class="line">        desiredCapabilities.setCapability(&quot;appPackage&quot;, &quot;com.xueqiu.android&quot;);</span><br><span class="line">        desiredCapabilities.setCapability(&quot;appActivity&quot;, &quot;.view.WelcomeActivityAlias&quot;);</span><br><span class="line">        desiredCapabilities.setCapability(&quot;autoGrantPermissions&quot;, &quot;true&quot;);</span><br><span class="line"></span><br><span class="line">        URL remoteUrl &#x3D; new URL(&quot;http:&#x2F;&#x2F;localhost:4723&#x2F;wd&#x2F;hub&quot;);</span><br><span class="line"></span><br><span class="line">        driver &#x3D; new AndroidDriver(remoteUrl, desiredCapabilities);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void sampleTest() &#123;</span><br><span class="line">        #隐式等待</span><br><span class="line">        driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        #关闭提醒更新的弹窗</span><br><span class="line">        MobileElement temp &#x3D; (MobileElement) driver.findElementById(&quot;com.xueqiu.android:id&#x2F;image_cancel&quot;);</span><br><span class="line">        temp.click();</span><br><span class="line"></span><br><span class="line">        MobileElement el1 &#x3D; (MobileElement) driver.findElementById(&quot;com.xueqiu.android:id&#x2F;tv_search&quot;);</span><br><span class="line">        el1.click();</span><br><span class="line">        MobileElement el2 &#x3D; (MobileElement) driver.findElementById(&quot;com.xueqiu.android:id&#x2F;search_input_text&quot;);</span><br><span class="line">        el2.sendKeys(&quot;alibaba&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After</span><br><span class="line">    public void tearDown() &#123;</span><br><span class="line">        driver.quit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此一个简单的appium测试例子就完成了。在这过程中首先利用appium的录制功能熟悉了如何获取元素，操作元素，并利用录制生成的代码稍加修改后完成了用代码驱动测试的过程。其中由于需要用到app的某些属性，还用到了adb(application debug bridge),这里直接给出了属性，后面会有专门的一篇文章来写相关的东西。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在之前的学习中已经搭好了基于MAC的Appium Desktop平台，在此基础上利用appium来做一个简单的测试例子。由于appium测试的模式是CS模式，client发起请求，server接收到该请求后来操作待测试的app。因此测试实例需要有client，server，app。这里server就是appium desktop，app利用Android studio提供的模拟器中的app，最后client就是我们写的测试代码。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Appium" scheme="http://yoursite.com/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>Appium等待机制</title>
    <link href="http://yoursite.com/2020/02/28/Appium%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/02/28/Appium%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6/</id>
    <published>2020-02-28T06:05:09.000Z</published>
    <updated>2020-06-05T02:10:21.617Z</updated>
    
    <content type="html"><![CDATA[<p>在任何GUI测试代码中，等待机制都是无法避免的一个话题，因为元素的出现都是需要时间的。如何不设置等待时间自动化代码很有可能因为找不到元素而失败，而无限制的加等待的代码又会使得程序运行的时间过长而失去了测试的意义。在appium中也有几种等待机制，需要在程序中合理利用它们。</p><a id="more"></a><h3 id="强制等待"><a href="#强制等待" class="headerlink" title="强制等待"></a>强制等待</h3><pre><code>import timetime.sleep();  </code></pre><h3 id="隐式等待（服务端）"><a href="#隐式等待（服务端）" class="headerlink" title="隐式等待（服务端）"></a>隐式等待（服务端）</h3><pre><code>1.python:self.driver.implicitly_wait(5000)2.java:driver.manage().timeouts().implicitlyWait(30, TimeUnit.SECONDS);</code></pre><p>该等待是webdirver提供的一个超时等待。当使用了隐式等待执行测试的时候，如果 WebDriver没有在 DOM中找到元素，将继续等待，超出设定时间后则抛出找不到元素的异常。一旦设置了隐式等待，则它存在整个 WebDriver 对象实例的声明周期中，隐式的等到会让一个正常响应的应用的测试变慢。</p><h3 id="显示等待（客户端）"><a href="#显示等待（客户端）" class="headerlink" title="显示等待（客户端）"></a>显示等待（客户端）</h3><pre><code>WebDriverWait(driver, timeout, poll_frequency=0.5, ignored_exceptions=None)driver - WebDriver 的驱动程序(Ie, Firefox, Chrome 或远程)timeout - 最长超时时间，默认以秒为单位poll_frequency - 休眠时间的间隔（步长）时间，默认为 0.5 秒ignored_exceptions - 超时后的异常信息，默认情况下抛 NoSuchElementException 异常。  </code></pre><p>WebDriverWait()：同样也是 webdirver 提供的方法。在设置时间内，默认每隔一段时间检测一次当前。页面元素是否存在，如果超过设置时间检测不到则抛出异常。  </p><p>WebDriverWait()一般由 until()或 until_not()方法配合使用，下面是 until()和 until_not()方法的说明。<br>until(method, message=’’)<br>调用该方法提供的驱动程序作为一个参数，直到返回值不为 False。<br>until_not(method, message=’’)<br>调用该方法提供的驱动程序作为一个参数，直到返回值为 False。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在任何GUI测试代码中，等待机制都是无法避免的一个话题，因为元素的出现都是需要时间的。如何不设置等待时间自动化代码很有可能因为找不到元素而失败，而无限制的加等待的代码又会使得程序运行的时间过长而失去了测试的意义。在appium中也有几种等待机制，需要在程序中合理利用它们。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Appium" scheme="http://yoursite.com/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>基于MAC的Appium Desktop环境搭建</title>
    <link href="http://yoursite.com/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</id>
    <published>2020-02-25T12:30:22.000Z</published>
    <updated>2020-06-05T02:10:21.675Z</updated>
    
    <content type="html"><![CDATA[<p>appium是一款开源的移动端自动化测试框架, appium可以测试Android或者iOS平台的原生应用，web浏览器应用以及混合应用。appium在设计时认为不应该让移动端自动化测试限定在某种语言和某个具体的框架中，也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试。</p><a id="more"></a><p>因此appium选择了client-server的设计模式。只要client能够发送http请求给server，那么client用任何语言来实现都是可以的，因此appium做到了支持多语言。其次appium扩展了webdriver的协议，没有重新去实现一套webdriver。这样的好处是以前的webdriver api能够直接被继承过来，各种语言的binding都可以拿来就用，省去了为每种语言开发一个client的工作量。</p><p>appium的核心其实是一个暴露了一系列REST API的server。这个server的功能其实很简单：监听一个端口，然后接收由client发送来的command。翻译这些command，把这些command转成移动设备可以理解的形式发送给移动设备，然后移动设备执行完这些command后把执行结果返回给appium server，appium server再把执行结果返回给client。</p><h3 id="一-安装appium-desktop"><a href="#一-安装appium-desktop" class="headerlink" title="一 安装appium desktop"></a>一 安装appium desktop</h3><h4 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h4><ul><li><p>安装brew并且更新</p><pre><code>curl -LsSf http://github.com/mxcl/homebrew/tarball/master | sudo tar xvz -C/usr/local --strip 1  brew update</code></pre></li><li><p>安装node.js</p><pre><code>brew install node  </code></pre></li><li><p>安装jdk，此处省略该步骤  </p></li><li><p>安装Android studio  </p></li></ul><h4 id="2-安装Appium"><a href="#2-安装Appium" class="headerlink" title="2.安装Appium"></a>2.安装Appium</h4><ul><li>go to <a href="https://github.com/appium/appium-desktop/releases/tag/v1.15.1" target="_blank" rel="noopener">https://github.com/appium/appium-desktop/releases/tag/v1.15.1</a> 并且下载合适的版本。这里以下载的是mac版本的appium。 <img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/appium下载.png" width="50%" height="50%">  </li><li>安装下载好的安装包,过程较为简单，不赘述。  </li><li>启动appium desktop，会看到如下界面：<img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/appium界面.png" width="50%" height="50%">  点击启动server后会出现server界面：  <img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/appium server.png" width="50%" height="50%">  </li></ul><h4 id="3-安装Appium-Doctor"><a href="#3-安装Appium-Doctor" class="headerlink" title="3.安装Appium-Doctor"></a>3.安装Appium-Doctor</h4><pre><code>npm install -g appium-doctor</code></pre><p>遇到问题：权限不够无法安装。  </p><img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/appium_doctor安装问题.png" width="50%" height="50%">   <p>解决办法如下：使用管理员权限来运行该命令。</p><pre><code>sudo npm install -g appium-doctor</code></pre><h4 id="4-运行Appium-Doctor"><a href="#4-运行Appium-Doctor" class="headerlink" title="4.运行Appium-Doctor"></a>4.运行Appium-Doctor</h4><p>打开terminal，运行appium-doctor  </p><img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/appium_desktop运行结果.png" width="50%" height="50%">  <p>从运行结果中看到需要解决三个问题： </p><p>1） carthage was not found<br>2） ANDOID_HOME is not set<br>3） JAVA_HOME is not set<br>解决办法为：<br>1）安装carthage</p><pre><code>brew install arthage</code></pre><p>如果提示权限不够就先运行下列代码，再下载carthage：</p><pre><code>sudo chown -R `whoami`:admin/usr/local/binsudo chown -R `whoami`:admin/usr/local/bin/share</code></pre><p>2)配置JAVA_HOME和ANDROID_HOME</p><pre><code>1.export ANDROID_HOME=/Users/jytu/Library/Android/sdk2.export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_201.jdk/Contents/Home3.export PATH=~/bin:$PATH:/usr/local/bin:$ANDROID_HOME/platform-tools/:$JAVA_HOME/bin4.export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre><p>再次运行appium-doctor时会显示变量已经配置好。</p><h4 id="5-配置appium"><a href="#5-配置appium" class="headerlink" title="5.配置appium"></a>5.配置appium</h4><p>打开appium，点击edit configurations，把之前配置好的JAVA_HOME和ANDROID_HOME输入并保存</p><img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Appium configurations.png" width="50%" height="50%"> <img src="/2020/02/25/%E5%9F%BA%E4%BA%8EMAC%E7%9A%84Appium%20Desktop%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/Appium configurations2.png" width="50%" height="50%"> <p>此时appium在MAC上就装好了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;appium是一款开源的移动端自动化测试框架, appium可以测试Android或者iOS平台的原生应用，web浏览器应用以及混合应用。appium在设计时认为不应该让移动端自动化测试限定在某种语言和某个具体的框架中，也就是说任何人都可以使用自己最熟悉最顺手的语言以及框架来做移动端自动化测试。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Appium" scheme="http://yoursite.com/tags/Appium/"/>
    
  </entry>
  
  <entry>
    <title>魔幻的2020</title>
    <link href="http://yoursite.com/2020/02/19/%E9%AD%94%E5%B9%BB%E7%9A%842020/"/>
    <id>http://yoursite.com/2020/02/19/%E9%AD%94%E5%B9%BB%E7%9A%842020/</id>
    <published>2020-02-19T09:02:22.000Z</published>
    <updated>2020-06-05T02:10:21.696Z</updated>
    
    <content type="html"><![CDATA[<p>2019年12月底时，弟弟在群里发了几张微博的截图，图中有人质疑武汉是不是发生了非典，我当时并没有特别的感受，想着大概又是某些网友的恶意造谣。而且说起非典，那一年我十岁，对此事并没有太多的记忆。此时的我，正期盼着新年的到来，2020，谐音爱你爱你，我心想这一年从数字上听起来就是一个充满爱意的年份，肯定会有很多美好的事情发生。甚至不在周末工作的民政局也发出声明会在2月2号这个美好而特殊的日子里为新人们办理结婚证。一切都像渐渐显示踪迹的春日，充满希望。</p><a id="more"></a><p>2020年1月20日，回家的前一天。正在上班的我发现不论是在办公室里还是电梯间，到处都能听到人们在议论武汉肺炎的声音。我看了一眼微博的热搜，武汉肺炎事件高居榜首。此时我意识到事情似乎并没有那么简单，之前的微博截图也许并不是造谣，但真相如何也未能得知。由于网络的发达，各种匪夷所思的事情都能见到，久而久之我便不再信任网络上的很多新闻。因而我仍然未意识到事情的严重性。但是有些同事已经警觉起来了，纷纷提醒我注意安全，燕儿也专门给我发微信让我戴口罩。因为明天我即将回家过年，而家乡小城离武汉只有两小时车程，许多人将从武汉回到家乡。晚上回到家，何同学问我，要不今年就不回家过年了吧，万一网上说的事情是真的，那回家会有点危险。我心里有点犹豫，但爸爸妈妈都未表现出担忧而是沉浸在我即将回家的喜悦中，毕竟好几个月没见了。由此我想着也许并没有网上那么严重,又是网友们过度宣传了。因此，第二天我依然踏上了回家的高铁，但为了以防万一，我提前买好了口罩。上高铁后我发现有一些人也戴上了戴口罩，但是并不多，妈妈甚至打电话给我，让我不要瞎紧张。但本着谨慎小心的态度，我在高铁上全程戴上了口罩。</p><p>2020年1月22日，回家的第二天，我们全家人邀请了弟弟的女朋友来家小聚，一家人开开心心的吃了一顿新年的团圆饭。饭后我还邀请弟弟的女朋友过年期间有时间就来家里玩。那时候大家依然没有意识到问题的严重性，仍然觉得这是一个普通的春节。网上有一个笑话，说全中国都觉得武汉被隔离了，但是武汉人民没有觉得自己被隔离了，依然该买年货就买年货，该逛街就逛街。那时候不仅是武汉人民，湖北地区人民估计都是这个状态。然而大家都没有意识到这是噩梦的开端。</p><p>2020年1月23日，早上醒来后突然发现网上铺天盖地的都是武汉肺炎的消息，顿时感受到了一丝恐慌，我赶紧和弟弟去买口罩。在找寻几家药店未果后，我才明白过来小镇的药店已经买不到口罩了。此刻内心很着急，于是我赶紧让在西安的何同学给我买了一大堆口罩寄过来，好在西安还未受到影响，口罩还能买到。回到家后我和弟弟数着家里仅有的口罩，看看能够用多久，那一刻拿着口罩真心觉得自己仿佛是在拿着一堆宝贝。此时电视，微博，微信，各大平台都在报道和肺炎相关的事情，而自己也意识到了问题的严重性，充满了恐慌心理，晚上无法好好睡觉，脑子里都是肺炎的事情，毕竟我回家经过了武汉，虽然只是短暂的停留，但是谁知道会发生什么事情。晚上爸爸和亲戚们打电话，取消了要去三叔家吃的团圆饭，和去奶奶家的拜年。全家人都觉得不能再出去了，出去便会增加感染风险，这个是无法承受的。</p><p>2020年1月26号，妈妈在做晚饭，爸爸在群里刷到一条消息，说超市可能要关门。妈妈就立刻解开围裙喊我一起出门去买东西。我们买了一袋大米，两代盐，三代面条。当无法出门时，充足的食物总能让人安心。第二天小区就被封了，我们都庆幸在那之前买了一些食物，否则将会更加恐慌</p><p>2020年2月3号，家里第一次出门采购，给妈妈准备好手套帽子，嘱咐爸爸一定要不要摘头盔和口罩，仿佛即将上战场，然而这只是去一趟超市啊。无法言喻的感觉，怎么我们的日常生活的充满了各种危险，出去一趟就会增加感染的风险，什么时候才能好起来，什么时候才能走出门去。看着每日增加的感染数量，放下的心又揪起来，在这个医疗条件不佳的小城市一旦感染，我不敢去想，甚至不敢打出这些字。真心希望早日战胜疫情，大家平平安安！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年12月底时，弟弟在群里发了几张微博的截图，图中有人质疑武汉是不是发生了非典，我当时并没有特别的感受，想着大概又是某些网友的恶意造谣。而且说起非典，那一年我十岁，对此事并没有太多的记忆。此时的我，正期盼着新年的到来，2020，谐音爱你爱你，我心想这一年从数字上听起来就是一个充满爱意的年份，肯定会有很多美好的事情发生。甚至不在周末工作的民政局也发出声明会在2月2号这个美好而特殊的日子里为新人们办理结婚证。一切都像渐渐显示踪迹的春日，充满希望。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Fiddler抓包实例</title>
    <link href="http://yoursite.com/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/"/>
    <id>http://yoursite.com/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/</id>
    <published>2020-02-18T11:40:57.000Z</published>
    <updated>2020-06-05T02:10:21.617Z</updated>
    
    <content type="html"><![CDATA[<p>Fiddler是一个常用的抓包软件，Fiddler可以拦截请求，在修改参数后重新提交请求。</p><a id="more"></a><p>1.官网下载<a href="https://www.telerik.com/fiddler" target="_blank" rel="noopener">Fiddler</a>，并进行安装。<br>2.由于Fiddler是默认抓取http请求，因此对于https请求，需要更改Fiddler的设置，并在浏览器上安装证书。操作如下：</p><ul><li><p><strong>更改Fiddler设置</strong><br>打开Fiddler，点击Tools&gt;Options&gt;HTTPS，勾选Decrypt HTTPS traffic。 </p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/1.png" width="50%" height="50%"><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/2.png" width="50%" height="50%"></li><li><p><strong>导出证书</strong><br>点击Actions按钮，生成证书并导出证书。  </p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/3.png" width="50%" height="50%"><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/4.png" width="50%" height="50%"></li><li><p>导入证书<br>1)这里使用的是chrome浏览器，打开Settings&gt;Privacy and security,点击Privacy and security  </p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/5.png" width="50%" height="50%"><p>2)点击导入证书，并选取之前生成的证书，继续下一步直到证书导入成功。</p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/6.png" width="50%" height="50%"><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/7.png" width="80%" height="80%"></li></ul><p>3.Fiddler实践<br>1)拦截请求，命令：bpu。例如想要拦截 <a href="https://www.baidu.com/，" target="_blank" rel="noopener">https://www.baidu.com/，</a> 则<br>在Fiddler命令行中输入<br>bpu <a href="https://www.baidu.com/，" target="_blank" rel="noopener">https://www.baidu.com/，</a> 并按下Enter键,命令行下方会提示已设置好断点。<br><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/8.png" width="50%" height="50%"><br>&ensp;&ensp;&ensp;<img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/9.png" width="50%" height="50%">  </p><p>2)打开chrome浏览器，输入并按下enter键，此时可以发现，网页并不能跳转到百度页面，因为我们设置了对该请求进行拦截，所以此时请求被拦截，网页无法跳转。打开Fiddler，可以看到下图：  </p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/10.png" width="80%" height="50%">  <p>如果点击GO,则请求将会释放拦截,网页可以正常跳转。  </p>   <img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/11.png" width="50%" height="50%"><p>接着搜索Java，网页继续被拦截一直处于loading状态</p>  <img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/12.png" width="50%" height="50%"><p>点击找到对应请求，修改参数为C++，并点击run to completation。则搜索结果会变为c++的相关信息。</p><img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/13.png" width="50%" height="50%">      <img src="/2020/02/18/Fiddler%E6%8A%93%E5%8C%85%E5%AE%9E%E4%BE%8B/14.png" width="45%" height="45%">]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fiddler是一个常用的抓包软件，Fiddler可以拦截请求，在修改参数后重新提交请求。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Fiddler" scheme="http://yoursite.com/tags/Fiddler/"/>
    
  </entry>
  
  <entry>
    <title>初识Gatling</title>
    <link href="http://yoursite.com/2020/02/17/%E5%88%9D%E8%AF%86Gatling/"/>
    <id>http://yoursite.com/2020/02/17/%E5%88%9D%E8%AF%86Gatling/</id>
    <published>2020-02-17T11:51:06.000Z</published>
    <updated>2020-06-05T02:10:21.654Z</updated>
    
    <content type="html"><![CDATA[<p>Gatling是一款基于Scala开发的高性能服务器性能测试工具，它主要用于对服务器进行负载等测试，并分析和测量服务器的各种性能指标。Gatling主要用于测量基于HTTP的服务器，比如Web应用程序，RESTful服务等。</p><a id="more"></a><h3 id="获取Gatling"><a href="#获取Gatling" class="headerlink" title="获取Gatling"></a><strong>获取Gatling</strong></h3><p>1.官网下载Gatling<br><a href="gatling">https://gatling.io/open-source/</a><br>2.下载好后解压，会得到如下几个文件夹:  </p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/8.png" width="300" height="200"><p>各个文件夹的作用如下，其中target文件夹会在运行测试后才产生。  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/9.png" alt="avatar"></p><h3 id="使用Gatling进行测试"><a href="#使用Gatling进行测试" class="headerlink" title="使用Gatling进行测试"></a><strong>使用Gatling进行测试</strong></h3><p>1.首先利用自带的脚本来运行测试，从而熟悉整个测试流程。打开命令行窗口并进入Gatling的bin文件夹目录下。  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/1.png" alt="avatar">  </p><p>2.执行命令gatling.bat，命令行窗口会显示出所有的测试用例  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/2.png" alt="avatar"></p><p>3.输入0，连续两次按下Enter键，运行第一个测试用例。  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/3.png" alt="avatar"></p><p>4.运行一段时间后会得到运行结果  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/4.png" alt="avatar">  </p><p>5.在文件夹results里面也会生成详细的运行结果报告。  </p><p><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/5.png" alt="avatar"><br><img src="/2020/02/17/%E5%88%9D%E8%AF%86Gatling/6.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Gatling是一款基于Scala开发的高性能服务器性能测试工具，它主要用于对服务器进行负载等测试，并分析和测量服务器的各种性能指标。Gatling主要用于测量基于HTTP的服务器，比如Web应用程序，RESTful服务等。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Gatling" scheme="http://yoursite.com/tags/Gatling/"/>
    
  </entry>
  
  <entry>
    <title>新年的仪式感</title>
    <link href="http://yoursite.com/2020/01/02/%E6%96%B0%E5%B9%B4%E7%9A%84%E4%BB%AA%E5%BC%8F%E6%84%9F/"/>
    <id>http://yoursite.com/2020/01/02/%E6%96%B0%E5%B9%B4%E7%9A%84%E4%BB%AA%E5%BC%8F%E6%84%9F/</id>
    <published>2020-01-02T07:30:22.000Z</published>
    <updated>2020-06-05T02:10:21.691Z</updated>
    
    <content type="html"><![CDATA[<p>2019年12月31日9点45分，我坐在沙发上，打开电视的同时刷着微信朋友圈。此时未到零点，但跃入眼前的已满是与跨年相关的朋友圈。有人在简书上写了一篇文章，用文字和照片总结了过往一年的点点滴滴，表达了对2019的肯定和不舍。有人发了九宫格，用照片记录过往，用文字诉说对来年的企盼。也有人只有简单的一两句话，祝大家新年快乐，希望新的一年平安喜乐。</p><a id="more"></a><p>何同学问我怎么不发朋友圈，证明一下新年即将到来，自己正在跨年。我笑了笑，说，大概是我长大了，越来越平常心了。是啊，此时的我真的非常平静，内心只觉得2019.12.31和2020.1.1对于我而言只是无数个日日夜夜中的两天而已，虽是新旧交替之际，却没有让我内心泛起波澜。我搜索了一下记忆，印象最深的跨年还是大三考研那年的冬天，我和几个小伴们偷偷溜出自习室，买了一小瓶白酒，吃着路边摊，一起祝贺新年的到来。往后便是发发朋友圈，感叹一下时光飞逝，到如今却是连朋友圈也不发了。我想，这是成熟了吧，用平常心面对越来越多的事情，这样也很好。临睡前再刷了一次朋友圈，依旧是和新年相关的居多，其中也有一些坚持学习英语的打卡记录以及某个同学分享自己在2019年最后一天拿到教师资格证的喜悦。但是躺下后我却无法很快入眠，思绪不禁飘回了浏览过的一条条朋友圈上。</p><p>我忍不住在想，真的是我平常心了么？还是因为我过去一年没有取得足够多的成绩，对未来一年没有计划才让我如此。于是大半夜的我进行了一次反思。从毕业以后到现在，我进入了一个相对懒散的状态，虽然也有着每日自我安慰式的学习，但内心着实觉得远远不够。我感觉自己似乎在上学时候用尽了所有学习的力气，现如今自我驱动的学习劲头实在太弱了。每日只想干好分内的工作，其余的并不想多想。这种状态一度让我感受到害怕，想着这么下去我就要被同时入职的人远远抛在后面了吧。于是在2019年的最后一个晚上，我进行了一些反省。我突然意识到平常心很好，但也许此时的我其实是需要一些仪式来记录一些事情。这个仪式并不拘泥于发朋友圈的形式，而可以是任何自我总结，自我反省的方式，对过去的表现加以总结，对未来定下目标。这样子才是在慢慢朝前走吧，我真的很担心在不知不觉间我的脚步已慢慢落后，终究只能望着别人的背影渐行渐远。</p><p>于是，便有了这篇流水账般的文章，希望这是一个好的开始。那么让我也给自己一点仪式感，给自己定下2020年的小目标。<br>1.锻炼身体，每周至少跑步一次<br>2.学习英语，争取完成英语打卡计划<br>3.考证<br>4.将在极客时间的订阅课程认真学完，并各输出两篇文章<br>5.学习API测试，mobile测试，各输出两篇文章<br>6.session3次<br>7.阅读专业书籍2本，其他书籍2本</p><p>我相信这会是一个好的开始，我希望2020年我会过得更加充实，在2020年末时我能肯定的对自己说过去的一年你辛苦啦，这一年里你成长了很多，进步了很多，不要担心未来，因为你也在向前走。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019年12月31日9点45分，我坐在沙发上，打开电视的同时刷着微信朋友圈。此时未到零点，但跃入眼前的已满是与跨年相关的朋友圈。有人在简书上写了一篇文章，用文字和照片总结了过往一年的点点滴滴，表达了对2019的肯定和不舍。有人发了九宫格，用照片记录过往，用文字诉说对来年的企盼。也有人只有简单的一两句话，祝大家新年快乐，希望新的一年平安喜乐。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="日常" scheme="http://yoursite.com/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
</feed>
